## Codebase Patterns
- Use Spring Boot 4.0.1 with Java 21 for this project
- Temporal Java SDK 1.32.1 is configured to connect to localhost:7233
- Maven wrapper (./mvnw) is used for all build commands
- Application starts on port 8080
- docker-compose.yml manages Kafka and MongoDB (NOT Temporal)
- Temporal runs via separate `temporal server start-dev` command

---

## 2026-01-26 13:52 - story-1

**What was implemented:**
- Created Spring Boot 4.0.1 project structure with Java 21
- Added Maven wrapper for consistent builds
- Created pom.xml with latest stable dependencies:
  - Spring Boot 4.0.1
  - Temporal Java SDK 1.32.1
  - Spring WebSocket for future real-time UI
  - Spring Kafka for event integration
  - MongoDB for persistence
- Created docker-compose.yml with Kafka (7.8.0) and MongoDB (8.0)
- Created Application.java with @SpringBootApplication
- Created application.yml with Temporal configuration (localhost:7233, flight-task-queue)
- Created comprehensive README.md with prerequisites and quick start

**Files changed:**
- pom.xml (created)
- src/main/java/com/temporal/jetstream/Application.java (created)
- src/main/resources/application.yml (created)
- docker-compose.yml (created)
- README.md (created)
- mvnw, mvnw.cmd, .mvn/wrapper/* (Maven wrapper)
- .gitignore (already existed, no changes needed)

**Learnings for future iterations:**
- Spring Boot 4.0.1 is the latest stable version (as of January 2026)
- Spring Boot 4.0 requires Java 17 minimum but supports Java 21 and Java 25
- Had to clean up duplicate Application.java file in com.example package that was causing build failure
- ./mvnw clean install completes successfully in under 1 second (after initial dependency download)
- Application starts successfully in ~0.6 seconds and connects to MongoDB
- Temporal server must be started separately with `temporal server start-dev` (not in docker-compose)
- Task queue is configured as "flight-task-queue" for workflow operations

---
## 2026-01-26 14:00 - story-2

**What was implemented:**
- Created Flight domain model class with all required fields:
  - flightNumber, flightDate, departureStation, arrivalStation
  - scheduledDeparture, scheduledArrival, currentState, gate, aircraft, delay
- Created FlightState enum with all lifecycle states:
  - SCHEDULED, BOARDING, DEPARTED, IN_FLIGHT, LANDED, COMPLETED, CANCELLED
- Created FlightWorkflow interface with @WorkflowInterface and @WorkflowMethod annotations
- Implemented FlightWorkflowImpl with deterministic state machine:
  - Transitions through states: SCHEDULED -> BOARDING -> DEPARTED -> IN_FLIGHT -> LANDED -> COMPLETED
  - Uses Workflow.sleep(Duration.ofSeconds(2)) between state transitions for simulation
  - Proper logging at each state transition
- Created TemporalConfig @Configuration class:
  - Creates WorkflowServiceStubs, WorkflowClient, WorkerFactory, and Worker beans
  - Registers FlightWorkflowImpl to 'flight-task-queue'
  - Worker starts automatically via @PostConstruct and stops via @PreDestroy
- Created comprehensive unit tests using TestWorkflowEnvironment:
  - Test with TestWorkflowExtension for simplified testing
  - Test with manual TestWorkflowEnvironment setup and WorkflowId verification
  - Both tests verify workflow completes with COMPLETED state

**Files changed:**
- src/main/java/com/temporal/jetstream/model/Flight.java (created)
- src/main/java/com/temporal/jetstream/model/FlightState.java (created)
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflow.java (created)
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflowImpl.java (created)
- src/main/java/com/temporal/jetstream/config/TemporalConfig.java (created)
- src/test/java/com/temporal/jetstream/workflow/FlightWorkflowTest.java (created)
- prd.json (updated story-2 passes: true)

**Learnings for future iterations:**
- Workflow implementations must be deterministic - use Workflow.sleep() not Thread.sleep()
- Use Workflow.getLogger() for logging within workflows, not standard loggers
- TestWorkflowExtension provides cleaner test setup with automatic worker registration
- WorkflowId format should be 'flight-{flightNumber}-{flightDate}' for uniqueness
- TemporalConfig uses @PostConstruct to start worker after Spring context initialization
- Worker logs 'Worker started for task queue: flight-task-queue' on successful startup
- Unit tests complete quickly (~1.3 seconds) using in-memory test server
- Application startup shows 'Registered FlightWorkflowImpl for task queue: flight-task-queue'
- FlightWorkflowImpl doesn't need @Workflow annotation (interface is sufficient)
- Flight domain model initializes with SCHEDULED state and 0 delay by default

---
## 2026-01-26 14:01 - story-3

**What was implemented:**
- Added three @SignalMethod annotations to FlightWorkflow interface:
  - announceDelay(int minutes) - signals flight delay
  - changeGate(String newGate) - signals gate change
  - cancelFlight(String reason) - signals flight cancellation
- Implemented signal handlers in FlightWorkflowImpl:
  - Added instance variables to track signal data (delayMinutes, currentGate, cancelled, cancellationReason)
  - announceDelay updates delayMinutes and logs the event
  - changeGate updates currentGate and logs the event
  - cancelFlight sets cancelled flag and transitions workflow to CANCELLED state
- Implemented early termination logic for cancellation:
  - Workflow checks cancelled flag after each state transition
  - When cancelled, immediately transitions to CANCELLED state and exits
- Created helper method updateFlightWithSignalData() to apply signal changes to Flight object
- Added comprehensive unit tests for signal handling:
  - testAnnounceDelaySignal - verifies delay signal updates delay field
  - testChangeGateSignal - verifies gate change signal updates gate field
  - testCancelFlightSignal - verifies cancellation terminates workflow early with CANCELLED state
  - testMultipleSignals - verifies multiple signals (delay + gate change) work together

**Files changed:**
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflow.java (added 3 signal methods)
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflowImpl.java (added signal handlers and cancellation logic)
- src/test/java/com/temporal/jetstream/workflow/FlightWorkflowTest.java (added 4 signal tests)
- prd.json (updated story-3 passes: true)

**Learnings for future iterations:**
- Signal methods must be idempotent - safe to receive multiple times
- Signals are processed asynchronously and can arrive at any point during workflow execution
- Use workflow instance variables to store signal data (not static variables)
- Workflow.await() can be used for more sophisticated signal handling with conditions
- cancelFlight demonstrates how signals can alter workflow control flow and cause early termination
- Test signals by starting workflow asynchronously (WorkflowStub.start()) then sending signals before getting result
- TestWorkflowEnvironment makes signal testing fast (<3 seconds for all 6 tests)
- Signal handlers show up in logs with format: "Received signal: [signalName], [parameters]"
- Cancellation checks after each Workflow.sleep() ensure timely response to cancel signals

---
## 2026-01-26 14:02 - story-4

**What was implemented:**
- Added three @QueryMethod annotations to FlightWorkflow interface:
  - getCurrentState() - Returns current FlightState enum value
  - getFlightDetails() - Returns complete Flight object with all current data
  - getDelayMinutes() - Returns current delay in minutes (0 if not delayed)
- Implemented query methods in FlightWorkflowImpl:
  - Added currentFlight instance variable to track flight state for queries
  - getCurrentState() returns the current state from currentFlight
  - getFlightDetails() creates a new Flight object with current state plus signal data (delay, gate)
  - getDelayMinutes() returns the delayMinutes instance variable
- Created comprehensive unit tests for all query methods:
  - testGetCurrentStateQuery - Verifies state can be queried during execution
  - testGetFlightDetailsQuery - Verifies complete details can be queried, including signal changes
  - testGetDelayMinutesQuery - Verifies delay can be queried before/after signal
  - testQueriesWithSignalsIntegration - Integration test showing queries work with signals
- Updated README.md with query examples and documentation:
  - Added "Querying Flight State" section with code examples
  - Documented query methods and key features (non-blocking, read-only, real-time, consistent)

**Files changed:**
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflow.java (added 3 @QueryMethod annotations)
- src/main/java/com/temporal/jetstream/workflow/FlightWorkflowImpl.java (added currentFlight variable and 3 query method implementations)
- src/test/java/com/temporal/jetstream/workflow/FlightWorkflowTest.java (added 4 new query tests)
- README.md (added "Querying Flight State" section)
- prd.json (updated story-4 passes: true)

**Learnings for future iterations:**
- Query methods must NOT modify workflow state - they are read-only
- Queries are synchronous and return immediately without blocking workflow execution
- Query methods return strongly consistent data with the workflow's current execution state
- getFlightDetails() creates a new Flight object to avoid returning internal mutable state
- Queries can be called on running workflows to inspect state in real-time
- Query results reflect signal changes immediately (e.g., after announceDelay signal, getDelayMinutes returns updated value)
- All 10 tests pass (6 original + 4 new query tests) in ~4.5 seconds
- TestWorkflowEnvironment makes queries execute very fast, so workflows may complete before queries in tests
- Instance variables (currentFlight, delayMinutes) are safe to use in query methods since they're accessed synchronously
- Query methods should be lightweight - no heavy computation or external calls

---
## 2026-01-26 14:10 - story-5

**What was implemented:**
- Created FlightController @RestController with REST API endpoints for workflow operations:
  - POST /api/flights/start - Start new flight workflow, returns workflowId
  - POST /api/flights/{flightNumber}/delay - Send announceDelay signal with minutes parameter
  - POST /api/flights/{flightNumber}/gate - Send changeGate signal with newGate parameter
  - POST /api/flights/{flightNumber}/cancel - Send cancelFlight signal with reason parameter
  - GET /api/flights/{flightNumber}/state - Query current flight state
  - GET /api/flights/{flightNumber}/details - Query complete flight details
- Created DTOs for request validation and responses:
  - StartFlightRequest with @NotBlank and @NotNull validation annotations
  - StartFlightResponse, AnnounceDelayRequest, ChangeGateRequest, CancelFlightRequest
  - FlightStateResponse and ErrorResponse for API responses
- All endpoints accept optional flightDate query parameter (defaults to today if not provided)
- Controller uses @Autowired WorkflowClient from Spring context
- Proper HTTP status codes: 200 (success), 404 (workflow not found), 500 (errors)
- WorkflowNotFoundException caught and returned as 404 with error message
- Added spring-boot-starter-validation dependency to pom.xml for @Valid support
- Updated README with comprehensive REST API documentation and curl examples for all endpoints

**Files changed:**
- src/main/java/com/temporal/jetstream/controller/FlightController.java (created)
- src/main/java/com/temporal/jetstream/dto/StartFlightRequest.java (created)
- src/main/java/com/temporal/jetstream/dto/StartFlightResponse.java (created)
- src/main/java/com/temporal/jetstream/dto/AnnounceDelayRequest.java (created)
- src/main/java/com/temporal/jetstream/dto/ChangeGateRequest.java (created)
- src/main/java/com/temporal/jetstream/dto/CancelFlightRequest.java (created)
- src/main/java/com/temporal/jetstream/dto/FlightStateResponse.java (created)
- src/main/java/com/temporal/jetstream/dto/ErrorResponse.java (created)
- pom.xml (added spring-boot-starter-validation dependency)
- README.md (added REST API Endpoints section with curl examples)
- prd.json (updated story-5 passes: true)

**Learnings for future iterations:**
- FlightController uses WorkflowClient.newWorkflowStub() with WorkflowOptions to start workflows
- WorkflowId format: "flight-{flightNumber}-{flightDate}" ensures unique workflow per flight per day
- Use WorkflowClient.start(workflow::method, args) to start workflows asynchronously
- For signals: get stub by workflowId and call signal methods directly on the stub
- For queries: get stub by workflowId and call query methods directly on the stub
- WorkflowNotFoundException is thrown when querying/signaling non-existent workflows
- @Valid annotation on request bodies triggers Spring validation based on constraint annotations
- Spring Boot 4.0 requires spring-boot-starter-validation for jakarta.validation support
- Controller tests require running Temporal server, so integration tests verify controller wiring
- Workflow functionality is already comprehensively tested in FlightWorkflowTest (10 passing tests)
- REST endpoints can be manually tested with curl when application is running via ./mvnw spring-boot:run
- buildWorkflowId() helper method defaults to today's date if flightDate parameter is null
- getWorkflowStub() helper method creates workflow stub from workflowId for signals/queries
- All endpoints log operations for debugging (e.g., "Started flight workflow: AA1234 with ID: flight-AA1234-2026-01-26")

---
## 2026-01-26 14:18 - story-6

**What was implemented:**
- Added previousFlightNumber and nextFlightNumber linkage fields to Flight model
- Created MultiLegFlightWorkflow interface with:
  - executeJourney(List<Flight>) method to orchestrate multi-leg journeys
  - getJourneyStatus() query method to inspect journey progress
  - getCurrentLegIndex() query method to track which leg is active
  - cancelJourney(String reason) signal method to cancel entire journey
- Implemented MultiLegFlightWorkflowImpl with child workflow orchestration:
  - Uses Workflow.newChildWorkflowStub() to start child FlightWorkflow instances for each leg
  - Parent workflow waits for each leg to complete before starting next leg
  - Handles compensation logic when any leg is cancelled (cascades to subsequent legs)
  - Transfers aircraft info from completed leg to next leg
  - Implements turnaround time delay between legs (1 second simulation)
- Created StartJourneyRequest and StartJourneyResponse DTOs for journey API
- Added POST /api/flights/journey endpoint to FlightController:
  - Accepts array of flight requests representing journey legs
  - Sets linkage fields between flights (previousFlightNumber, nextFlightNumber)
  - Starts MultiLegFlightWorkflow with journey-{journeyId} workflow ID format
- Registered MultiLegFlightWorkflowImpl in TemporalConfig alongside FlightWorkflowImpl
- Created comprehensive test suite with 5 test cases:
  - testThreeLegJourney: Verifies 3-leg journey (ORD->DFW->LAX->SFO) completes successfully
  - testJourneyWithCancelJourneySignal: Tests cancellation via parent workflow signal
  - testAircraftTransferBetweenLegs: Verifies aircraft is transferred between legs
  - testJourneyStatusQuery: Tests querying journey status during execution
  - testSingleLegJourney: Edge case test for single-leg journey

**Files changed:**
- src/main/java/com/temporal/jetstream/model/Flight.java (added linkage fields)
- src/main/java/com/temporal/jetstream/workflow/MultiLegFlightWorkflow.java (created)
- src/main/java/com/temporal/jetstream/workflow/MultiLegFlightWorkflowImpl.java (created)
- src/main/java/com/temporal/jetstream/dto/StartJourneyRequest.java (created)
- src/main/java/com/temporal/jetstream/dto/StartJourneyResponse.java (created)
- src/main/java/com/temporal/jetstream/controller/FlightController.java (added journey endpoint)
- src/main/java/com/temporal/jetstream/config/TemporalConfig.java (registered multi-leg workflow)
- src/test/java/com/temporal/jetstream/workflow/MultiLegFlightWorkflowTest.java (created)
- prd.json (updated story-6 passes: true)

**Learnings for future iterations:**
- Child workflows are created using Workflow.newChildWorkflowStub() with ChildWorkflowOptions
- ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON allows child workflows to continue if parent terminates
- Must import ParentClosePolicy from io.temporal.api.enums.v1.ParentClosePolicy (not from EncodedValues)
- Each child workflow gets independent WorkflowId: "flight-{flightNumber}-{flightDate}"
- Parent workflow can wait for child completion by calling child workflow method directly
- When testing workflows that return List<T>, avoid using WorkflowStub.getResult(List.class) as it returns LinkedHashMap instead of typed objects
- Instead, use query methods to retrieve state or call workflow method directly via typed stub
- TestWorkflowExtension doesn't have getTaskQueue() method; use worker.getTaskQueue() instead
- Child workflows show up in execution history with START_CHILD_WORKFLOW_EXECUTION_INITIATED events
- Compensation logic: when one leg cancels, parent can cancel all subsequent legs
- Aircraft/crew info can be passed between legs by updating Flight object after leg completes
- All 15 tests pass (10 from FlightWorkflowTest + 5 from MultiLegFlightWorkflowTest)

---
## 2026-01-26 14:29 - story-7

**What was implemented:**
- Created WebSocketConfig class for real-time communication:
  - Configured STOMP messaging protocol over WebSocket with SockJS fallback
  - Enabled simple in-memory message broker for broadcasting to clients
  - WebSocket endpoint at /ws for client connections
- Implemented FlightEventService to publish flight state changes:
  - publishFlightUpdate(Flight) sends complete flight details to /topic/flights
  - publishStateChange() sends event notifications to /topic/flight-events
  - Autowired SimpMessagingTemplate for WebSocket message broadcasting
- Updated FlightController to publish events after operations:
  - Added FlightEventService injection
  - Publishing flight updates after delay, gate change, and cancel signals
  - Publishing state change events when flights start
- Fixed TemporalConfig worker startup issue:
  - Moved workerFactory.start() directly into worker() @Bean method
  - Removed @PostConstruct that wasn't firing due to timing issues
  - Worker now starts immediately after registration
- Created comprehensive web UI with three static files:
  - index.html: Bootstrap-based UI with flight list, details panel, modals, and event log
  - styles.css: Custom styling for flight cards, state badges, and animations
  - app.js: WebSocket connection handling, API interactions, and real-time updates
- Updated README with Web UI section including:
  - Access instructions
  - Feature list
  - Real-time update explanation
  - Step-by-step usage guide

**Files changed:**
- src/main/java/com/temporal/jetstream/config/WebSocketConfig.java (created)
- src/main/java/com/temporal/jetstream/service/FlightEventService.java (created)
- src/main/java/com/temporal/jetstream/config/TemporalConfig.java (fixed worker startup)
- src/main/java/com/temporal/jetstream/controller/FlightController.java (added event publishing)
- src/main/resources/static/index.html (created)
- src/main/resources/static/styles.css (created)
- src/main/resources/static/app.js (created)
- README.md (added Web UI section)
- prd.json (updated story-7 passes: true)

**Learnings for future iterations:**
- STOMP over WebSocket with SockJS provides excellent fallback support for older browsers
- SimpMessagingTemplate from spring-messaging makes it trivial to broadcast to WebSocket topics
- Spring Boot automatically serves static files from src/main/resources/static at root URL
- index.html in static folder becomes the welcome page automatically
- WorkerFactory.start() must be called for workers to poll for tasks - @PostConstruct timing can be problematic
- Moving workerFactory.start() into the @Bean method ensures it fires after all dependencies are ready
- WebSocket connection status is important for UX - users need to know if real-time updates are working
- Bootstrap + vanilla JS provides a lightweight UI without heavy framework dependencies
- SockJS client library provides WebSocket polyfill for maximum compatibility
- STOMP.js provides clean abstraction over WebSocket protocol
- Flight workflows complete very quickly (8 seconds with 2-second sleeps between states)
- WebSocket publishes work best when called AFTER signals/operations complete
- Query the workflow after signal to get updated state for WebSocket broadcast
- All 15 tests still pass after UI implementation
- UI is accessible at http://localhost:8080 once application starts
- Real-time updates work immediately - no polling needed
- WebSocket automatically reconnects after disconnection

---
